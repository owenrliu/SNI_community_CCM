---
title: "Brown Algae and Invertebrates at San Nicolas Island"
author: "Owen Liu"
date: "August 16, 2016"
output: html_document
---

## An Empirical Dynamic Exploration

This project will use data from a long-term monitoring project at San Nicolas Island to investigate dynamic interactions and predictability between kelp forest brown algae species (*Macrocystis pyrifera* and understory kelps), and various species of invertebrates.  We will see how well these species can predict each other's dynamics, and resolve competitive and predatory/herbivorous interactions in real time across the timeframe of the dataset.  The species we will look at are:

* Brown algaes:
  + *Macrocystis pyrifera*, giant kelp
  + *Laminaria* species (combined)
  + *Cystoseira osmundacea*
  + *Pterogophora californica*
  + *Eisenia arborea*, southern sea palm

* Echinoderms
  + *Strongylocentrotus purpuratus*, purple sea urchin
  + *S. franciscanus*, red sea urchin
  + *Patiria miniata*, bat star
  + *Pisaster giganteus*, giant sea star
  + *Parastichopus parvimensis*, warty sea cucumber

* Gastropods
  + *Megastraea undosa*, wavy turban snail

```{r setup, include=FALSE}
library(ggplot2)
library(tidyr)
library(dplyr)
library(tseries)
library(rEDM)
library(reshape2)

#### Data ####
# The raw data has been processed into a set of normalized time series elsewhere.
W_D <- getwd()
dat.long <- read.csv(paste0(W_D,"/data/combined_processed_benthic_data.csv")) %>% select(-X)

# These data have more species than we need. These next lines pull out the relevant species for this study from the larger dataset and produce a block (wide-form) dataset.  Keep in mind, these data are from multiple transects across multiple sites on the small islands. Empirical dynamic modeling can use multiple spatial replicates to produce increased predictability by concatenating them into one long time series. We preserve a time indicator (variable 'period') to ensure that we do not "cross" the boundaries of replicate time series in following analyses.

# Species Key for all benthic density species
#*************************************
spp.key <- read.csv(file=paste(W_D,'/data/Table4_Species_sampled.csv',sep=''),stringsAsFactors = F) # All species, all surveys
spp.key.bdens <- spp.key %>% filter(DataSet=="Benthic density")

# better names
spp.key.bdens$name <- c("pat","red","purp","wavy","astro","derm","halc","halr","limp","paras","pis","pyc","cys","lam","ymac","youn","eis","pter","mac")
# ************************************

# Filter for our species of interest.
#*************************************
study_spp <- c("pat","red","purp","wavy","paras","pis","cys","lam","eis","pter","mac")
dat.filt <- dat.long %>% filter(spp %in% study_spp)
#*************************************

# Now, we can normalize the time series, and cast to "wide" form data (where rows are time periods and columns are species)

#Normalize ts ((x-mean(x))/sd(x))
# ************************************
dat.norm <- dat.filt %>%
  group_by(spp,site) %>%
  mutate(norm=(dens-mean(dens,na.rm=T))/sd(dens,na.rm=T)) %>%
  ungroup() %>%
  unique()
#*************************************
# Now, we can normalize the time series, and cast to "wide" form data (where rows are time periods and columns are species)

#Normalize ts ((x-mean(x))/sd(x))
# ************************************
dat.norm <- dat.filt %>%
  group_by(spp,site) %>%
  mutate(norm=(dens-mean(dens,na.rm=T))/sd(dens,na.rm=T)) %>%
  ungroup() %>%
  unique()
#*************************************

# Cast to wide form
#*************************************
dat.norm.block <- dat.norm %>%
  select(-dens) %>%
  spread(key=spp,value=norm) %>%
  arrange(site)
#*************************************
```

### Getting a Sense of the Data

Our first task is just to look at the data over time. Let's explore (normalized) time series of our different variables.

```{r data first look}
plot(dat.norm.block$mac,type="l",main="Macrocystis time series",xlab="time",ylab="normalized density")
plot(dat.norm.block$lam,type="l",main="Laminaria time series",xlab="time",ylab="normalized density")
plot(dat.norm.block$pter,type="l",main="Pterogophora time series",xlab="time",ylab="normalized density")
plot(dat.norm.block$red,type="l",main="Red urchin time series",xlab="time",ylab="normalized density")

# For many of these time series, the last few 'sites', from SNI station 7, in the combined time series look like they have different dynamics. Let's remove them from the data.  We do more quantitative tests of the validity of combining sites' data below.

dat.norm.block <- dat.norm.block %>% filter(!grepl("7",site))
```

### Establishing univariate predictability and nonlinearity
For each of these time series, we have a few steps to see if they seem appropriate to analyze together.  First, for each species/variable separately, we'll search for signals of deterministic behavior, or self-predictability, using simplex projection (which will also give us an idea of the appropriate embedding dimension). Then, we look for nonlinear dynamics with S-maps.  Finally, we can determine cross-predictability across sites to make sure it is appropriate to use all the data together.

First, let's use simplex projection to investigate each species' self predictability.

```{r univariate simplex}
# For all the steps in the univariate analyses, we need an indication of the breaks in the different sites, or concurrent time series
# This piece of code holds the row numbers of the first and last element of each time series
segs_sites <- dat.norm.block %>%  
  mutate(ind = row_number()) %>% 
  group_by(site) %>%
  summarise(first=first(ind),last=last(ind))

segs <- select(segs_sites,-site)

# For this step, we use all the concatenated data
simp.list <- list() # list to store output

par(mfrow=c(2,2))
for(i in 1:length(study_spp)) {
  spp <- study_spp[i]
  dat <- dat.norm.block %>% select(matches(spp)) %>% as.data.frame()
  out <- simplex(as.numeric(dat[,1]),lib=as.matrix(segs),silent=T)
  simp.list[[spp]] <- out
  
  # Plot embedding dimension vs. predictive ability (rho)
  plot(out$E,out$rho,type="l",main=spp,xlab="Embedding Dimension (E)",ylab=expression(paste("Self-Forecast Skill, ",rho)))

}
```

We can also look at prediction decay, another important property of deterministic chaos. This makes sure that nearby trajectories eventually diverge over time (the "butterfly effect"). Helps in distinguishing nonlinear systems from equilibrium-type systems. We want prediction to decline over time. For this simplex projection, we hold E, the embedding dimension, constant, and vary the prediction horizon, tp

```{r prediction horizon}
# Find best embedding dimension from previous step
bestE <- sapply(simp.list,function(x) x$E[x$rho==max(x$rho)])
tp.list <- list()

par(mfrow=c(2,2))
plot.new()
for(i in 1:length(study_spp)) {
  spp <- study_spp[i]
  dat <- dat.norm.block %>% select(matches(spp)) %>% as.data.frame()
  out <- simplex(as.numeric(dat[,1]),lib=as.matrix(segs),silent=T,E=bestE[i],tp=1:10)
  tp.list[[spp]] <- out
  
  # Plot embedding dimension vs. predictive ability (rho)
  plot(out$tp,out$rho,type="l",main=spp,xlab="Time to Prediction",ylab=expression(paste("Self-Forecast Skill, ",rho)))
}
```

All of the variables show a decent ability to self-predict, as shown by simplex projection.  Some of them require high embedding dimensions, though, which is somewhat worrying. However, the butterfly effect check is promising, as all variables decline in predictive ability with time horizon.  For now, we'll keep all variables.

Next is to look for nonlinearity with S-maps. The S-maps procedure has a parameter, $\theta$, that can "tune" the projection algorithm to weight local state-space neighborhoods more highly, the implication being that if predictability improves with increased $\theta$, variables are better predicted by local neighborhoods rather than global linear models, indicating state-dependence or nonlinearity of dynamics.

For prediction of each variable, we'll use the optimal embedding dimension found in the previous step (the E with highest predictive ability).

```{r univariate s_maps}
smap.list <- list() # list to store output

par(mfrow=c(2,2))
for(i in 1:length(study_spp)) {
  spp <- study_spp[i]
  dat <- dat.norm.block %>% select(matches(spp)) %>% as.data.frame()
  out <- s_map(as.numeric(dat[,1]),lib=as.matrix(segs),E=bestE[i],silent=T)
  simp.list[[spp]] <- out
  
  # Plot embedding dimension vs. predictive ability (rho)
  plot(out$theta,out$rho,type="l",main=spp,xlab=expression(paste("Nonlinearity (",theta,")")),ylab=expression(paste("Self-Predictive Ability ",rho)))
}

ptm<-proc.time()
test<-simplex(as.numeric(dat[,1]),lib=as.matrix(segs)[1:5,],pred=as.matrix(segs)[11:15,],silent=T)
proc.time()-ptm
```

All variables show significantly improved predictive ability with increased theta, suggesting strong nonlinear dynamics.
Together, the simplex and S-map results suggest our approach is valid--variables are predictable, but predictable in a nonlinear way.

Now we have to check to see if different sites have cross-predictability, to validate our choice to pool all of the data. To do this is a bit tricky. The data collected at San Nicolas Island is nested: transects within sites.  Here, we'll keep the individual transect time series within each site pooled, but test for predictability *between sites*.

For each species, we'll use simplex projection, but varying the "library" and "prediction" sets to explicit match the 6 different sites and see how well they can cross-predict.  Because this is not necessarily a symmetrical process (e.g., for a given species, site 1 may predict the dynamics of site 2 better than site 2 can predict site 1), there will be 36 runs for each species (6 sites times 6 crosses per site, itself and the 5 other sites).  To make the output cleaner, we'll simply extract the best rho from each run, and ensure that it is significantly greater than zero.

```{r data combination check}
# For each individual simplex run, we use a subset of the block data, according to the original segments key:
site_rows <- segs_sites %>% 
  separate(site,into=c("site","transect"),sep="_") %>%
  select(-transect) %>%
  as.data.frame()

# This is a list, each element holding an identifier of the subset time series (the transects) within each site.
site_rows_list <- split(site_rows,site_rows$site)
# Possible combinations of sites
site.combinations <- expand.grid(1:6,1:6) %>% 
  rename(libs=Var1,preds=Var2)

# List to hold output of cross-checks
dat.comb.check <- list()

# Run the simplex projections
for(i in 1:length(study_spp)) {
  spp <- study_spp[i]
  dat <- dat.norm.block %>% select(matches(spp)) %>% as.data.frame()
  dat <- as.numeric(dat[,1])
  out.mat <- matrix(nrow=6,ncol=6,dimnames=list(as.character(1:6),as.character(1:6)))
  
  # For each species, test each combination of sites
  for(j in 1:nrow(site.combinations)) {
    # Form a set of library and prediction vectors from different sites
    lib <- site.combinations[j,1]
    pred <- site.combinations[j,2]
    
    # Run the simplex model, pulling the correct library and prediction vectors from the list of site-specific time series
    simp <- simplex(dat,lib=as.matrix(site_rows_list[[lib]][,2:3]),pred=as.matrix(site_rows_list[[pred]][,2:3]),silent=T)
    
    # Pull out the best predictive ability between the two sites. If all p-values (using Fisher's z) greater than 0.05, return NA
    if(min(simp$p_val>0.05)) {
      out <- NA
    } else {
      out <- max(simp$rho)
    }
    out.mat[lib,pred] <- out
  }
  
  # For each species, return matrix of sites' cross-predictability
  dat.comb.check[[spp]] <- out.mat
}
```

We can plot 6 by 6 raster-type grids for each species, displaying the results of this exercise.

<<<<<<< HEAD
```{r site cross prediction plots, echo=F}
# List to hold plot output
x_predict_plots <- list()

# Create a raster for each species result from the previous step
master_raster <- data_frame(species=character(),lib=character(),pred=character(),rho=numeric())

for(i in 1:length(dat.comb.check)) {
  spp <- names(dat.comb.check)[i]
  
  # Raster data for plotting
  sppmat <- as.data.frame(dat.comb.check[[i]])
  cross.rast <- sppmat %>% 
    mutate(lib=row.names(sppmat)) %>% 
    gather(key=pred,value=rho,1:6) %>%
    arrange(desc(rho)) %>%
    mutate(species=study_spp[i])
  master_raster <- bind_rows(master_raster,cross.rast)
}
  # Plot
x_predict_by_spp <- ggplot(master_raster,aes(x=lib,y=pred,fill=rho)) +
  geom_raster() +
  scale_fill_distiller(palette="Spectral",limits=c(0.1,0.9),name=expression(paste(rho, "(max skill)"))) +
  ggtitle(paste("Site Cross Predictability by Species")) +
  xlab("Library Site") +
  ylab("Forecasted Site")+
  facet_wrap(~species)

x_predict_by_spp
ggsave("x_pred_spp.png")
```

Rows or columns that appear gray (NA, non-significant forecast skill) or very cool (blue-ish) in these plots indicate sites for each species that may not be appropriate to include, as their dynamics are not significantly cross-predictable.  A couple of things to notice:

* All species have high ($\rho$ >0.5) cross-predictability at some sites
* *Megastraea*'s dynamics at site 5 seem to be both unpredictable, and not useful for predicting other sites.
* *Pisaster* is difficult to forecast at sites 5 and 6
* There is some evidence that sites that are closest spatially (e.g., sites 2/3 and 4/5) have the most cross-predictability of dynamics, which makes sense.  This will not be examined further here, but worth noting.

The next step will be to see if these species show signs of causative links.

### Determining Causation Between Species

Generalizations of Takens' theorem indicate that if two variables (in our case, species) are part of the same dynamic system, their individual dynamics should reflect their relative causal influence. In other words, if one variable (for example, giant kelp), is casually forced by another (sea urchins), that forcing should leave a signature on the giant kelp time series. Convergent cross mapping (CCM) tests for causation by using the attractor/manifold built from the time series of one variable to forecast another. If the attractor can accurately (based on out-of-sample prediction skill, just as before) predict the dynamics of the second variable, we can claim that the second variable has a causal influence on the first.  In other words, if A causes B, we should be able to recover the dynamics of A using a reconstruction of B. We say that the *causal effect of A on B is determined by how well B cross-maps A*.

Cross-mapping can distinguish unidirectional forcing (A forces B but B doesn't force A) from bi-directional (A and B force each other). It can also resolve transitive causal chains (A causes B causes C).  To look for a causal signal, we plot predictive skill against library size (the number of embedded vectors used to construct the attractor). Convergence means that cross-mapped estimates improve with library length, because the attractor is more fully resolved and estimation error should decline.

We can use this theory to build a causal network in our kelp forest algae/invertebrate system.

CCM uses a random sampling method to test multiple "versions" of each library size, sampling from the supplied library vectors to give a sense of the confidence intervals around prediction skill. However, just like before, because we're using multiple, simultaneous time series, we have to indicate the breaks in those time series so the algorithm does not try to make predictions spanning multiple time series. Also, to be more conservative, we'll use only a random half of each time series for attractor reconstruction, and apply it to predicting the other half.

```{r CCM segments}
# Block of time series for running CCM. Same as before, with the site identifier removed.
CCM.block <- dat.norm.block %>% select(-site) %>% as.data.frame()

set.seed(42)
# Sample one half of time series segments, without replacement
rnd_lib_segs <- sample_frac(segs,0.5,replace=F) %>% arrange(first)
# Use other half for prediction
rnd_pred_segs <- anti_join(segs,rnd_lib_segs,by=c("first","last")) %>% arrange(first)

rnd_lib_segs <- as.matrix(rnd_lib_segs)
rnd_pred_segs <- as.matrix(rnd_pred_segs)
```

We can now apply CCM. Let's start simple, and see which invertebrates seem to have a causal influence on *Macrocystis pyrifera*, the giant kelp, and vice versa. We accomplish this by building a library with *Macrocystis* vectors, and cross-mapping the invertebrates

```{r CCM macro}
# Red urchin
mac_xmap_red <- ccm(CCM.block, lib=as.matrix(segs),pred=as.matrix(segs),E=bestE["mac"],lib_column = "mac",
                    target_column = "red",lib_sizes = c(seq(5,55,by=2),seq(55,400,by=50)),first_column_time = T,silent=T)
red_xmap_mac <- ccm(CCM.block, lib=as.matrix(segs),pred=as.matrix(segs),E=bestE["red"],lib_column = "red",
                    target_column = "mac",lib_sizes = c(seq(5,55,by=2),seq(55,400,by=50)),first_column_time = T,silent=T)
# To plot, we need to find means and sd's for each library size
mac_xmap_red_means <- mac_xmap_red %>% group_by(lib_size) %>% 
  summarise(mean.rho=mean(rho), sd.rho=sd(rho))
red_xmap_mac_means <- red_xmap_mac %>% group_by(lib_size) %>% 
  summarise(mean.rho=mean(rho), sd.rho=sd(rho))

ggplot()+
  geom_line(data=mac_xmap_red_means,aes(x=lib_size,y=mean.rho,color="Macrocystis xmap Red Urchin"))+
  geom_ribbon(data=mac_xmap_red_means,aes(x=lib_size,ymin=mean.rho-sd.rho,ymax=mean.rho+sd.rho,fill="Macrocystis xmap Red Urchin"),alpha=0.3)+
  geom_line(data=red_xmap_mac_means,aes(x=lib_size,y=mean.rho,color="Red Urchins xmap Macrocystis"))+
  geom_ribbon(data=red_xmap_mac_means,aes(x=lib_size,ymin=mean.rho-sd.rho,ymax=mean.rho+sd.rho,fill="Red Urchins xmap Macrocystis"),alpha=0.3)+
  scale_colour_manual(name=NULL, labels=c("Macrocystis xmap Red Urchin","Red Urchins xmap Macrocystis"),values=c("darkred","darkgreen"))+
  scale_fill_manual(name=NULL, labels=c("Macrocystis xmap Red Urchin","Red Urchins xmap Macrocystis"),values=c("darkred","darkgreen"))+
  theme(legend.key = element_blank(),legend.justification=c(0,1), legend.position=c(0,1))+
  ylim(-0.1,0.15) +
  ggtitle("Macrocystis and Red Urchin Cross Mapping")+
  xlab("Library size")+
  ylab(expression(paste("Cross-map skill, ",rho)))

## Macrocystis and purple urchins

mac_xmap_purp <- ccm(CCM.block, lib=as.matrix(segs),pred=as.matrix(segs),E=bestE["mac"],lib_column = "mac",
                    target_column = "purp",lib_sizes = c(seq(5,55,by=2),seq(55,400,by=50)),first_column_time = T,silent=T)
purp_xmap_mac <- ccm(CCM.block, lib=as.matrix(segs),pred=as.matrix(segs),E=bestE["purp"],lib_column = "purp",
                    target_column = "mac",lib_sizes = c(seq(5,55,by=2),seq(55,400,by=50)),first_column_time = T,silent=T)
# To plot, we need to find means and sd's for each library size
mac_xmap_purp_means <- mac_xmap_purp %>% group_by(lib_size) %>% 
  summarise(mean.rho=mean(rho), sd.rho=sd(rho))
purp_xmap_mac_means <- purp_xmap_mac %>% group_by(lib_size) %>% 
  summarise(mean.rho=mean(rho), sd.rho=sd(rho))

ggplot()+
  geom_line(data=mac_xmap_purp_means,aes(x=lib_size,y=mean.rho,color="Macrocystis xmap Purple Urchin"))+
  geom_ribbon(data=mac_xmap_purp_means,aes(x=lib_size,ymin=mean.rho-sd.rho,ymax=mean.rho+sd.rho,fill="Macrocystis xmap purp Urchin"),alpha=0.3)+
  geom_line(data=purp_xmap_mac_means,aes(x=lib_size,y=mean.rho,color="Purple Urchins xmap Macrocystis"))+
  geom_ribbon(data=purp_xmap_mac_means,aes(x=lib_size,ymin=mean.rho-sd.rho,ymax=mean.rho+sd.rho,fill="Purple Urchins xmap Macrocystis"),alpha=0.3)+
  scale_colour_manual(name=NULL, labels=c("Macrocystis xmap Purple Urchin","Purple Urchins xmap Macrocystis"),values=c("purple","darkgreen"))+
  scale_fill_manual(name=NULL, labels=c("Macrocystis xmap Purple Urchin","Purple Urchins xmap Macrocystis"),values=c("purple","darkgreen"))+
  theme(legend.key = element_blank(),legend.justification=c(0,1), legend.position=c(0,1))+
  ylim(-0.1,0.5) +
  ggtitle("Macrocystis and Purple Urchin Cross Mapping")+
  xlab("Library size")+
  ylab(expression(paste("Cross-map skill, ",rho)))
ggsave("x_pred_spp.png")
```

Rows or columns that appear gray or very cool (blue-ish) in these plots indicate sites for each species that may not be appropriate to include, as their dynamics are not significantly cross-predictable.
>>>>>>> 64291813f70ad714130d82800745d432ec226fa5
