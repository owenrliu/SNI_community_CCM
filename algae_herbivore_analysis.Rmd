---
title: "Brown Algae and Invertebrates at San Nicolas Island"
author: "Owen Liu"
date: "August 16, 2016"
output: html_document
---

## An Empirical Dynamic Exploration

### 1. Introduction
This project will use data from a long-term monitoring project at San Nicolas Island to investigate dynamic interactions and predictability between kelp forest brown algae species (*Macrocystis pyrifera* and understory kelps), and various species of invertebrates.  We will see how well these species can predict each other's dynamics, and resolve competitive and predatory/herbivorous interactions in real time across the timeframe of the dataset.  The species we will look at are:

* Brown algaes:
  + *Macrocystis pyrifera*, giant kelp
  + *Laminaria* species (combined)
  + *Cystoseira osmundacea*
  + *Pterogophora californica*
  + *Eisenia arborea*, southern sea palm

* Echinoderms
  + *Strongylocentrotus purpuratus*, purple sea urchin
  + *S. franciscanus*, red sea urchin
  + *Patiria miniata*, bat star
  + *Pisaster giganteus*, giant sea star
  + *Parastichopus parvimensis*, warty sea cucumber

* Gastropods
  + *Megastraea undosa*, wavy turban snail

```{r setup, include=FALSE}
library(ggplot2)
library(tidyr)
library(dplyr)
library(tseries)
library(rEDM)
library(reshape2)

#### Data ####
# The raw data has been processed into a set of normalized time series elsewhere.
W_D <- getwd()
dat.long <- read.csv(paste0(W_D,"/data/combined_processed_benthic_data.csv")) %>% select(-X)

# These data have more species than we need. These next lines pull out the relevant species for this study from the larger dataset and produce a block (wide-form) dataset.  Keep in mind, these data are from multiple transects across multiple sites on the small islands. Empirical dynamic modeling can use multiple spatial replicates to produce increased predictability by concatenating them into one long time series. We preserve a time indicator (variable 'period') to ensure that we do not "cross" the boundaries of replicate time series in following analyses.

# Species Key for all benthic density species
#*************************************
spp.key <- read.csv(file=paste(W_D,'/data/Table4_Species_sampled.csv',sep=''),stringsAsFactors = F) # All species, all surveys
spp.key.bdens <- spp.key %>% filter(DataSet=="Benthic density")

# better names
spp.key.bdens$name <- c("pat","red","purp","wavy","astro","derm","halc","halr","limp","paras","pis","pyc","cys","lam","ymac","youn","eis","pter","mac")
# ************************************

# Filter for our species of interest.
#*************************************
study_spp <- c("pat","red","purp","wavy","paras","pis","cys","lam","eis","pter","mac")
dat.filt <- dat.long %>% filter(spp %in% study_spp)
#*************************************

# Now, we can normalize the time series, and cast to "wide" form data (where rows are time periods and columns are species)

#Normalize ts ((x-mean(x))/sd(x))
# ************************************
dat.norm <- dat.filt %>%
  group_by(spp,site) %>%
  mutate(norm=(dens-mean(dens,na.rm=T))/sd(dens,na.rm=T)) %>%
  ungroup() %>%
  unique()
#*************************************

# Cast to wide form
#*************************************
dat.norm.block <- dat.norm %>%
  select(-dens) %>%
  spread(key=spp,value=norm) %>%
  arrange(site)
#*************************************
```

### 2. Getting a Sense of the Data

Our first task is just to look at the data over time. Let's explore (normalized) time series of our different variables.

```{r data first look}
plot(dat.norm.block$mac,type="l",main="Macrocystis time series",xlab="time",ylab="normalized density")
plot(dat.norm.block$lam,type="l",main="Laminaria time series",xlab="time",ylab="normalized density")
plot(dat.norm.block$pter,type="l",main="Pterogophora time series",xlab="time",ylab="normalized density")
plot(dat.norm.block$red,type="l",main="Red urchin time series",xlab="time",ylab="normalized density")

# For many of these time series, the last few 'sites', from SNI station 7, in the combined time series look like they have different dynamics. Let's remove them from the data.  We do more quantitative tests of the validity of combining sites' data below.

dat.norm.block <- dat.norm.block %>% filter(!grepl("7",site))
```

### 3. Establishing Univariate Predictability and Nonlinearity
For each of these time series, we have a few steps to see if they seem appropriate to analyze together.  First, for each species/variable separately, we'll search for signals of deterministic behavior, or self-predictability, using simplex projection (which will also give us an idea of the appropriate embedding dimension). Then, we look for nonlinear dynamics with S-maps.  Finally, we can determine cross-predictability across sites to make sure it is appropriate to use all the data together.

First, let's use simplex projection to investigate each species' self predictability.

```{r univariate simplex}
# For all the steps in the univariate analyses, we need an indication of the breaks in the different sites, or concurrent time series
# This piece of code holds the row numbers of the first and last element of each time series
segs_sites <- dat.norm.block %>%  
  mutate(ind = row_number()) %>% 
  group_by(site) %>%
  summarise(first=first(ind),last=last(ind))

segs <- select(segs_sites,-site)

# For this step, we use all the concatenated data
simp.list <- list() # list to store output

par(mfrow=c(2,2))
for(i in 1:length(study_spp)) {
  spp <- study_spp[i]
  dat <- dat.norm.block %>% select(matches(spp)) %>% as.data.frame()
  out <- simplex(as.numeric(dat[,1]),lib=as.matrix(segs),silent=T)
  simp.list[[spp]] <- out
  
  # Plot embedding dimension vs. predictive ability (rho)
  plot(out$E,out$rho,type="l",main=spp,xlab="Embedding Dimension (E)",ylab=expression(paste("Self-Forecast Skill, ",rho)))

}
```

We can also look at prediction decay, another important property of deterministic chaos. This makes sure that nearby trajectories eventually diverge over time (the "butterfly effect"). Helps in distinguishing nonlinear systems from equilibrium-type systems. We want prediction to decline over time. For this simplex projection, we hold E, the embedding dimension, constant, and vary the prediction horizon, tp

```{r prediction horizon}
# Find best embedding dimension from previous step
bestE <- sapply(simp.list,function(x) x$E[x$rho==max(x$rho)])
tp.list <- list()

par(mfrow=c(2,2))
plot.new()
for(i in 1:length(study_spp)) {
  spp <- study_spp[i]
  dat <- dat.norm.block %>% select(matches(spp)) %>% as.data.frame()
  out <- simplex(as.numeric(dat[,1]),lib=as.matrix(segs),silent=T,E=bestE[i],tp=1:10)
  tp.list[[spp]] <- out
  
  # Plot embedding dimension vs. predictive ability (rho)
  plot(out$tp,out$rho,type="l",main=spp,xlab="Time to Prediction",ylab=expression(paste("Self-Forecast Skill, ",rho)))
}
```

All of the variables show a decent ability to self-predict, as shown by simplex projection.  Some of them require high embedding dimensions, though, which is somewhat worrying. However, the butterfly effect check is promising, as all variables decline in predictive ability with time horizon.  For now, we'll keep all variables.

Next is to look for nonlinearity with S-maps. The S-maps procedure has a parameter, $\theta$, that can "tune" the projection algorithm to weight local state-space neighborhoods more highly, the implication being that if predictability improves with increased $\theta$, variables are better predicted by local neighborhoods rather than global linear models, indicating state-dependence or nonlinearity of dynamics.

For prediction of each variable, we'll use the optimal embedding dimension found in the previous step (the E with highest predictive ability).

```{r univariate s_maps}
smap.list <- list() # list to store output

par(mfrow=c(2,2))
for(i in 1:length(study_spp)) {
  spp <- study_spp[i]
  dat <- dat.norm.block %>% select(matches(spp)) %>% as.data.frame()
  out <- s_map(as.numeric(dat[,1]),lib=as.matrix(segs),E=bestE[i],silent=T)
  smap.list[[spp]] <- out
  
  # Plot embedding dimension vs. predictive ability (rho)
  plot(out$theta,out$rho,type="l",main=spp,xlab=expression(paste("Nonlinearity (",theta,")")),ylab=expression(paste("Self-Predictive Ability ",rho)))
}

ptm<-proc.time()
test<-simplex(as.numeric(dat[,1]),lib=as.matrix(segs)[1:5,],pred=as.matrix(segs)[11:15,],silent=T)
proc.time()-ptm
```

All variables show significantly improved predictive ability with increased theta, suggesting strong nonlinear dynamics.
Together, the simplex and S-map results suggest our approach is valid--variables are predictable, but predictable in a nonlinear way.

Now we have to check to see if different sites have cross-predictability, to validate our choice to pool all of the data. To do this is a bit tricky. The data collected at San Nicolas Island is nested: transects within sites.  Here, we'll keep the individual transect time series within each site pooled, but test for predictability *between sites*.

For each species, we'll use simplex projection, but varying the "library" and "prediction" sets to explicit match the 6 different sites and see how well they can cross-predict.  Because this is not necessarily a symmetrical process (e.g., for a given species, site 1 may predict the dynamics of site 2 better than site 2 can predict site 1), there will be 36 runs for each species (6 sites times 6 crosses per site, itself and the 5 other sites).  To make the output cleaner, we'll simply extract the best rho from each run, and ensure that it is significantly greater than zero.

```{r data combination check}
# For each individual simplex run, we use a subset of the block data, according to the original segments key:
site_rows <- segs_sites %>% 
  separate(site,into=c("site","transect"),sep="_") %>%
  select(-transect) %>%
  as.data.frame()

# This is a list, each element holding an identifier of the subset time series (the transects) within each site.
site_rows_list <- split(site_rows,site_rows$site)
# Possible combinations of sites
site.combinations <- expand.grid(1:6,1:6) %>% 
  rename(libs=Var1,preds=Var2)

# List to hold output of cross-checks
dat.comb.check <- list()

# Run the simplex projections
for(i in 1:length(study_spp)) {
  spp <- study_spp[i]
  dat <- dat.norm.block %>% select(matches(spp)) %>% as.data.frame()
  dat <- as.numeric(dat[,1])
  out.mat <- matrix(nrow=6,ncol=6,dimnames=list(as.character(1:6),as.character(1:6)))
  
  # For each species, test each combination of sites
  for(j in 1:nrow(site.combinations)) {
    # Form a set of library and prediction vectors from different sites
    lib <- site.combinations[j,1]
    pred <- site.combinations[j,2]
    
    # Run the simplex model, pulling the correct library and prediction vectors from the list of site-specific time series
    simp <- simplex(dat,lib=as.matrix(site_rows_list[[lib]][,2:3]),pred=as.matrix(site_rows_list[[pred]][,2:3]),silent=T)
    
    # Pull out the best predictive ability between the two sites. If all p-values (using Fisher's z) greater than 0.05, return NA
    if(min(simp$p_val>0.05)) {
      out <- NA
    } else {
      out <- max(simp$rho)
    }
    out.mat[lib,pred] <- out
  }
  
  # For each species, return matrix of sites' cross-predictability
  dat.comb.check[[spp]] <- out.mat
}
```

We can plot 6 by 6 raster-type grids for each species, displaying the results of this exercise.

```{r site cross prediction plots, echo=F,message=F}
# List to hold plot output
x_predict_plots <- list()

# Create a raster for each species result from the previous step
master_raster <- data_frame(species=character(),lib=character(),pred=character(),rho=numeric())

for(i in 1:length(dat.comb.check)) {
  spp <- names(dat.comb.check)[i]
  
  # Raster data for plotting
  sppmat <- as.data.frame(dat.comb.check[[i]])
  cross.rast <- sppmat %>% 
    mutate(lib=row.names(sppmat)) %>% 
    gather(key=pred,value=rho,1:6) %>%
    arrange(desc(rho)) %>%
    mutate(species=study_spp[i])
  master_raster <- bind_rows(master_raster,cross.rast)
}
  # Plot
x_predict_by_spp <- ggplot(master_raster,aes(x=lib,y=pred,fill=rho)) +
  geom_raster() +
  scale_fill_distiller(palette="Spectral",limits=c(0.1,0.9),name=expression(paste(rho, "(max skill)"))) +
  ggtitle(paste("Site Cross Predictability by Species")) +
  xlab("Library Site") +
  ylab("Forecasted Site")+
  facet_wrap(~species)

x_predict_by_spp
ggsave("x_pred_spp.png")
```

Rows or columns that appear gray (NA, non-significant forecast skill) or very cool (blue-ish) in these plots indicate sites for each species that may not be appropriate to include, as their dynamics are not significantly cross-predictable.  A couple of things to notice:

* All species have high ($\rho$ >0.5) cross-predictability at some sites
* *Megastraea*'s dynamics at site 5 seem to be both unpredictable, and not useful for predicting other sites.
* *Pisaster* is difficult to forecast at sites 5 and 6
* There is some evidence that sites that are closest spatially (e.g., sites 2/3 and 4/5) have the most cross-predictability of dynamics, which makes sense.  This will not be examined further here, but worth noting.

The next step will be to see if these species show signs of causative links.

### 4. Determining Causation Between Species

Generalizations of Takens' theorem indicate that if two variables (in our case, species) are part of the same dynamic system, their individual dynamics should reflect their relative causal influence. In other words, if one variable (for example, giant kelp), is casually forced by another (sea urchins), that forcing should leave a signature on the giant kelp time series. Convergent cross mapping (CCM) tests for causation by using the attractor/manifold built from the time series of one variable to forecast another. If the attractor can accurately (based on out-of-sample prediction skill, just as before) predict the dynamics of the second variable, we can claim that the second variable has a causal influence on the first.  In other words, if A causes B, we should be able to recover the dynamics of A using a reconstruction of B. We say that the *causal effect of A on B is determined by how well B cross-maps A*.

Cross-mapping can distinguish unidirectional forcing (A forces B but B doesn't force A) from bi-directional (A and B force each other). It can also resolve transitive causal chains (A causes B causes C).  To look for a causal signal, we plot predictive skill against library size (the number of embedded vectors used to construct the attractor). There are two criteria for CCM to establish causality. First, and most obviously, predictive cross-map skill using all available data should be significantly greater than zero. Second, that predictability should be convergent.  Convergence means that cross-mapped estimates improve with library length, because the attractor is more fully resolved and estimation error should decline.

We can use this theory to build a causal network in our kelp forest algae/invertebrate system.

CCM uses a random sampling method to test multiple "versions" of each library size, sampling from the supplied library vectors to give a sense of the confidence intervals around prediction skill. However, just like before, because we're using multiple, simultaneous time series, we have to indicate the breaks in those time series so the algorithm does not try to make predictions spanning multiple time series. Also, to be more conservative, we'll use only a random half of each time series for attractor reconstruction, and apply it to predicting the other half.

```{r CCM segments}
# Block of time series for running CCM. Same as before, with the site identifier removed.
CCM.block <- dat.norm.block %>% select(-site) %>% as.data.frame()

set.seed(4215)
# Sample one half of time series segments, without replacement
rnd_lib_segs <- sample_frac(segs,0.5,replace=F) %>% arrange(first)
# Use other half for prediction
rnd_pred_segs <- anti_join(segs,rnd_lib_segs,by=c("first","last")) %>% arrange(first)

rnd_lib_segs <- as.matrix(rnd_lib_segs)
rnd_pred_segs <- as.matrix(rnd_pred_segs)
```

We can now apply CCM. Let's start simple, and see which invertebrates seem to have a causal influence on *Macrocystis pyrifera*, the giant kelp, and vice versa. We accomplish this by building a library with *Macrocystis* vectors, and cross-mapping the invertebrates. For example, we can see if there is a causal signal between *Macrocystis* and the two urchin species:

```{r CCM macro, message=F, echo=F}
# zero cutoff function: if rho is less than zero, it doesn't make sense, so we'll set those values to zero for cleaner results
cut_to_zero <- function(x) sapply(x, function(y) ifelse(y<0,0,y))

# Red urchin
mac_xmap_red <- ccm(CCM.block, lib=as.matrix(rnd_lib_segs),pred=as.matrix(rnd_pred_segs),E=bestE["red"],lib_column = "mac",
                    target_column = "red",lib_sizes = c(seq(5,55,by=2),seq(55,1000,by=50)),first_column_time = T,silent=T)
red_xmap_mac <- ccm(CCM.block, lib=as.matrix(rnd_lib_segs),pred=as.matrix(rnd_pred_segs),E=bestE["mac"],lib_column = "red",
                    target_column = "mac",lib_sizes = c(seq(5,55,by=2),seq(55,1000,by=50)),first_column_time = T,silent=T)

# To plot, we need to find means and sd's for each library size
mac_xmap_red_means <- mac_xmap_red %>% 
  group_by(lib_size) %>% 
  summarise(mean.rho=mean(rho), sd.rho=sd(rho)) %>%
  mutate(upper=mean.rho+sd.rho, lower=mean.rho-sd.rho) %>%
  mutate_each(funs(cut_to_zero),-lib_size)

red_xmap_mac_means <- red_xmap_mac %>% 
  group_by(lib_size) %>% 
  summarise(mean.rho=mean(rho), sd.rho=sd(rho)) %>%
  mutate(upper=mean.rho+sd.rho, lower=mean.rho-sd.rho) %>%
  mutate_each(funs(cut_to_zero),-lib_size)

mac_x_red_plot <- ggplot()+
  geom_line(data=mac_xmap_red_means,aes(x=lib_size,y=mean.rho,color="Macrocystis xmap Red Urchin"))+
  geom_ribbon(data=mac_xmap_red_means,aes(x=lib_size,ymin=lower,ymax=upper,fill="Macrocystis xmap Red Urchin"),alpha=0.3)+
  geom_line(data=red_xmap_mac_means,aes(x=lib_size,y=mean.rho,color="Red Urchins xmap Macrocystis"))+
  geom_ribbon(data=red_xmap_mac_means,aes(x=lib_size,ymin=lower,ymax=upper,fill="Red Urchins xmap Macrocystis"),alpha=0.3)+
  scale_colour_manual(name=NULL, labels=c("Macrocystis xmap Red Urchin","Red Urchins xmap Macrocystis"),values=c("darkred","darkgreen"))+
  scale_fill_manual(name=NULL, labels=c("Macrocystis xmap Red Urchin","Red Urchins xmap Macrocystis"),values=c("darkred","darkgreen"))+
  theme(legend.key = element_blank(),legend.justification=c(0,1), legend.position=c(0,1),
        panel.background=element_rect(fill="white",color="black"))+
  geom_hline(yintercept=0,linetype=2,color="gray40")+
  ylim(-0.05,0.5) +
  ggtitle("Macrocystis and Red Urchin Cross Mapping")+
  xlab("Library size")+
  ylab(expression(paste("Cross-map skill, ",rho)))

## Macrocystis and purple urchins

mac_xmap_purp <- ccm(CCM.block, lib=as.matrix(rnd_lib_segs),pred=as.matrix(rnd_pred_segs),E=bestE["purp"],lib_column = "mac",
                    target_column = "purp",lib_sizes = c(seq(5,55,by=2),seq(55,1000,by=50)),first_column_time = T,silent=T)
purp_xmap_mac <- ccm(CCM.block, lib=as.matrix(rnd_lib_segs),pred=as.matrix(rnd_pred_segs),E=bestE["mac"],lib_column = "purp",
                    target_column = "mac",lib_sizes = c(seq(5,55,by=2),seq(55,1000,by=50)),first_column_time = T,silent=T)
# To plot, we need to find means and sd's for each library size
mac_xmap_purp_means <- mac_xmap_purp %>% 
  group_by(lib_size) %>% 
  summarise(mean.rho=mean(rho), sd.rho=sd(rho)) %>%
  mutate(upper=mean.rho+sd.rho, lower=mean.rho-sd.rho) %>%
  mutate_each(funs(cut_to_zero),-lib_size)

purp_xmap_mac_means <- purp_xmap_mac %>% group_by(lib_size) %>% 
  summarise(mean.rho=mean(rho), sd.rho=sd(rho))%>%
  mutate(upper=mean.rho+sd.rho, lower=mean.rho-sd.rho) %>%
  mutate_each(funs(cut_to_zero),-lib_size)

mac_x_purp_plot <- ggplot()+
  geom_line(data=mac_xmap_purp_means,aes(x=lib_size,y=mean.rho,color="Macrocystis xmap Purple Urchin"))+
  geom_ribbon(data=mac_xmap_purp_means,aes(x=lib_size,ymin=lower,ymax=upper,fill="Macrocystis xmap purp Urchin"),alpha=0.3)+
  geom_line(data=purp_xmap_mac_means,aes(x=lib_size,y=mean.rho,color="Purple Urchins xmap Macrocystis"))+
  geom_ribbon(data=purp_xmap_mac_means,aes(x=lib_size,ymin=lower,ymax=upper,fill="Purple Urchins xmap Macrocystis"),alpha=0.3)+
  scale_colour_manual(name=NULL, labels=c("Macrocystis xmap Purple Urchin","Purple Urchins xmap Macrocystis"),values=c("purple","darkgreen"))+
  scale_fill_manual(name=NULL, labels=c("Macrocystis xmap Purple Urchin","Purple Urchins xmap Macrocystis"),values=c("purple","darkgreen"))+
  theme(legend.key = element_blank(),legend.justification=c(0,1), legend.position=c(0,1),
        panel.background=element_rect(fill="white",color="black"))+
  geom_hline(yintercept=0,linetype=2,color="gray40")+
  ylim(-0.05,0.5) +
  ggtitle("Macrocystis and Purple Urchin Cross Mapping")+
  xlab("Library size")+
  ylab(expression(paste("Cross-map skill, ",rho)))

mac_x_red_plot
mac_x_purp_plot
```

This initial look suggests that both urchin species affect, and are affected by, the giant kelp. In the red urchin case, the *Macrocystis* seems to drive red urchin dynamics more than urchins drive kelp, but in the case of purple urchins, there is evidence of bi-directional causation.  For both cross-mappings, cross-map skill, while significantly greater than zero, is not particularly strong, suggesting there are other important variables to consider.

Applying CCM in this way to all combinations of species in our data, we can build a "causal web", looking at the strength of cross-map skill between all species.  Importantly, as evidenced by the red urchin example above, CCM is non-symmetrical, and hence the cross-map of A on B is not the same as the cross-map of B on A. For the sake of comparison, we can also build a traditional cross-correlation matrix between the same timeseries.

```{r CCM all species}
ncol <- dim(CCM.block)[2]-1
col.names <- colnames(CCM.block)[2:(ncol+1)]
xmap_mat <- array(NA,dim=c(ncol,ncol),dimnames=list(col.names,col.names))

## CCM causation criterion 1: cross-map skill greater than zero
# matrix to store a bootstrapped p-value, measuring the probability that a given xmap is greater than zero (calculated as 
# 1 minus the number of positive results for rho divided by the number of iterations)
p1.mat <- array(NA,dim=c(ncol,ncol),dimnames=list(col.names,col.names))

## CCM causation criterion 2: evidence for convergence
# similarly, matrix to store a bootstrapped p-value, this time a t-test value between library size 10 and library size 500, to see if the rho at large library is significantly greater than the rho at small library size (i.e., looking for convergence).  If rho does not converge with library length, it may be a sign of synchrony.
p2.mat <- array(NA,dim=c(ncol,ncol),dimnames=list(col.names,col.names))

# if both p1 and p2 are positive, indicate overall significant causal signal
ptot.mat <- array(NA,dim=c(ncol,ncol),dimnames=list(col.names,col.names))

## Run CCM for each combination of variables
for(i in 1:ncol) {
  for(j in 1:ncol) {
    if(i != j) {
      # remember, we use the best embedding dimension for the library variable (the predicted variable, j)
      tempE=bestE[col.names[j]]
      temp <- ccm(CCM.block,lib=rnd_lib_segs,pred=rnd_pred_segs,E=tempE,lib_column = 1+i,target_column = 1+j,
                  lib_sizes = c(10,500,1000),replace=T,silent=T)
      # mean rho at library size 500
      rhomean <- temp %>% filter(lib_size==1000) %>% ccm_means()
      xmap_mat[i,j] <- rhomean$rho
      
      # first p-value (greater than zero? at largest library size)
      p1 <- temp %>% filter(lib_size==1000) %>% mutate(pos=ifelse(rho>0,1,0)) %>% summarise(p=(1-sum(pos)/n()))
      p1.mat[i,j] <- as.numeric(p1)
      
      # second p-value (rho at lib-size 500 greater than rho at lib-size 10?)
      p2 <- t.test(temp$rho[temp$lib_size==10],temp$rho[temp$lib_size==500])$p.value
      p2.mat[i,j] <- as.numeric(p2)
      
      # overall significance (both p1 and p2 signficant at alpha 0.05)
      ptot.mat[i,j] <- ifelse(p1<0.05 & p2<0.05,1,0)
    }
  }
}
rm(tempE)
rm(temp)
```

We can output this result in a grid similar to before, except will all cross-species combinations instead of species x site

```{r CCM raster, echo=F}
xmap_rast <- as.data.frame(xmap_mat*ptot.mat) %>% 
  mutate(predictee=row.names(xmap_mat)) %>% 
  gather(key=predictor,value=rho,cys:wavy) %>%
  arrange(desc(rho))

# If rho is zero, replace with NA (no significant causal signal)
xmap_rast$rho[xmap_rast$rho==0] <- NA

## plot
xmap_all_plot <- ggplot(xmap_rast,aes(x=predictor,y=predictee,fill=rho)) +
  geom_raster() +
  scale_fill_distiller(palette="Spectral",name=expression(paste(rho, "(skill)"))) +
  ggtitle("Kelp Forest Convergent Cross Mapping") +
  xlab("Predictor") +
  ylab("Predictee") +
  theme(axis.text.x=element_text(angle = 90, hjust = 1,vjust=0.1))

xmap_all_plot
ggsave("xmap_all.png")
```

From this plot, we can draw a few conclusions.  The predictors (causal variables) lie along the x-axis (columns), and the variables they cause are on the y-axis (rows). The strongest forcing variables of giant kelp dynamics are actually not the urchins, but rather two understory kelps, *Laminaria spp.* and *Pterogophora californica*. The *Macrocystis*, in turn, displays a causal effct on purple urchins *Strongylocentrotus purpuratus*, and to a lesser extent red urchins *S. franciscanus*, *Laminaria*, and *Cystoseira osmundacea*.  Looking at the data another way, we can build an interaction web, and also see the number of link (causal or caused by) for each species (its network centrality).

```{r causal web and interactions, echo=F}
library(igraph) # Package for network graphing and analysis
g <- graph.adjacency(t(ptot.mat))
par(mfrow=c(1,1))
V(g)$label <- paste(sep="\n",V(g)$name, degree(g))
# vector of node colors for plotting
vert.cols <- c(rep("tan3",4),rep("orchid3",3),"tan3",rep("orchid3",2),"darkseagreen")

plot(g,asp=FALSE, vertex.label.color="black", vertex.label.cex=1, edge.arrow.size=0.6,vertex.label.font=2, vertex.size=20, edge.color="gray40",vertex.frame.color=F,vertex.color=vert.cols,edge.curved=F,main="Kelp Forest Causal Web")

legend(x=-1, y=-1, c("Brown Algae","Echinoderms", "Gastropods"), pch=21, pt.bg=c("tan3","orchid3","darkseagreen"), pt.cex=2, cex=.8, bty="n", ncol=1)
```

Although this is a busy network, it suggests two things to me, both of which agree with a lot of previous work:

* Kelp forests are dynamically complex, with an intricate network of causal interactions between species
* The algaes (primary producers) are central to dynamics, having the most connections, followed by the two urchin species

### 5. Adding Physical Variables

The steps we've taken so far have established the relationships and cross-predictability between algae and invertebrates species in kelp forests.  We've shown that dynamics for some species are quite predictable, and that there are some species that seem to be "central" to kelp forest dynamics as a whole.

However, one thing we haven't yet investigated is where physical forcing fits into the story. A body of other research has established that a combination of physical forcing (waves, storms), temperature, and lower frequency climate modes (e.g., El Ninos) have an important influence on the dynamics of kelp. In this section, we'll explore how those types of data influence the dynamics of our local-scale kelp forest species. Interestingly, by using cross-mapping, we'll be able to draw connections between the physical variables and not just *Macrocystis*, but all of the species in our constrained trophic web.

We have four datasets, already processed into the same time frame (periods) as the SNI benthic monitoring data:

* The Multivariate ENSO index (MEI)
  + The first principal component of a composite set of physical parameters
  + from NOAA, http://www.esrl.noaa.gov/psd/enso/mei
  + Variable here is the average index value for the four months preceding each Spring or Fall monitoring period (i.e., December to March or June to September, respectively)
* The Pacific Decadal Oscillation index (PDO)
  + Leading empirical orthogonal function (EOF) of monthly sea surface temperature anomalies (SST-A) over the North Pacific (poleward of 20Â° N) after the global average sea surface temperature has been removed
  + obtained from http://research.jisao.washington.edu/pdo/
  + Aggregated and averaged the same way as MEI
* The North Pacific Gyre Oscillation (NPGO)
  + from Di Lorenzo, 2008, http://www.o3d.org/npgo/
  + climate pattern that emerges as the 2nd dominant mode of sea surface height variability (2nd EOF SSH) in the Northeast Pacific
  + better correlated with salinity, nutrients, and chlorophyll than PDO
  + Aggregated and averaged the same way as MEI and PDO
* Sea surface temperature (SST)
  + Sea surface temperature data from Begg Rock and San Nicolas Island buoys, from the Coastal Data Information Program (CDIP), cdip.ucsd.edu
  + Incomplete data
  + Similar to the above, value is an average SST for the four months preceding each period
* Maximum significant wave height (Hs)
  + Also from the Begg and SNI buoys and the CDIP
  + Signficant wave height is defined as the average height, in meters, of the one third highest waves in the record
  + Instead of an average, value here is the maximum significant wave height of the four months preceding each period. This is meant to capture any large storm events, as well as general level of physical disturbance
  
As with the other variables in our analysis, these physical variables have been normalized to zero mean and unit variance to facilitate comparison among variables and not distort state-space reconstructions.

```{r physical variable import}
# Read in the variables
phys.dat <- read.csv(paste0(W_D,"/data/phys_vars_combined.csv"))
phys.dat.norm <- read.csv(paste0(W_D,"/data/phys_vars_combined_norm.csv"))

# Combine with CCM block data, by period
CCM.block.phys <- CCM.block %>% left_join(phys.dat.norm,by="period")
```

First, let's see if the time series of *Macrocystis pyrifera* can cross-map any of the physical variables. To do so, we need to determine if the physical variables are self-predictable and see if they show a nonlinear signal.  All physical variables are the same across the spatial replicates in the biological data, so for these tests, the library and prediction sets of vectors are just made up of the first 63 rows of the block (i.e., equivalent to one replicate)

```{r physical vars simplex}
phys.simp <- list()
phys.vars <- c("mei.mean","pdo.mean","npgo.mean","waves.max","sst.mean")
par(mfrow=c(2,2))
for(i in 1:length(phys.vars)) {
  ind <- phys.vars[i]
  dat <- CCM.block.phys %>% select(matches(ind)) %>% as.data.frame()
  out <- simplex(as.numeric(dat[,1]),lib=c(1,63),silent=T)
  phys.simp[[ind]] <- out
  
  # Plot embedding dimension vs. predictive ability (rho)
  plot(out$E,out$rho,type="l",main=ind,xlab="Embedding Dimension (E)",ylab=expression(paste("Self-Forecast Skill, ",rho)))
  
  bestE[ind] <- out$E[out$rho==max(out$rho)]
}
```

All physical variables have significant self-forecasting skill at relatively low embedding dimension.  What about a nonlinear signal?

```{r physical vars s_map}
phys.smap <- list()
par(mfrow=c(2,2))
for(i in 1:length(phys.vars)) {
  ind <- phys.vars[i]
  dat <- CCM.block.phys %>% select(matches(ind)) %>% as.data.frame()
  out <- s_map(as.numeric(dat[,1]),lib=c(1,63),E=bestE[ind],silent=T)
  phys.smap[[ind]] <- out
  
  # Plot embedding dimension vs. predictive ability (rho)
  plot(out$theta,out$rho,type="l",main=ind,xlab=expression(paste("Nonlinearity (",theta,")")),ylab=expression(paste("Self-Predictive Ability ",rho)))
}
```

All variables show significant nonlinearity except for the NPGO. We can now cross-map to see if any of the physical variables have significant predictive skill.

```{r ccm mac mei}
mac_xmap_mei <- ccm(CCM.block.phys,E=bestE["mei.mean"],lib=rnd_lib_segs,pred=rnd_pred_segs,lib_column="mac",target_column="mei.mean",lib_sizes=c(seq(5,55,by=5),seq(55,1000,by=50)),silent=T)

mei_xmap_mac <- ccm(CCM.block.phys,E=bestE["mac"],lib=rnd_lib_segs,pred=rnd_pred_segs,lib_column = "mei.mean", target_column = "mac",lib_sizes=c(seq(5,55,by=5),seq(55,1000,by=50)),silent=T)

# To plot, we need to find means and sd's for each library size
mac_xmap_mei_means <- mac_xmap_mei %>% 
  group_by(lib_size) %>% 
  summarise(mean.rho=mean(rho), sd.rho=sd(rho)) %>%
  mutate(upper=mean.rho+sd.rho, lower=mean.rho-sd.rho) %>%
  mutate_each(funs(cut_to_zero),-lib_size)

mei_xmap_mac_means <- mei_xmap_mac %>% 
  group_by(lib_size) %>% 
  summarise(mean.rho=mean(rho), sd.rho=sd(rho)) %>%
  mutate(upper=mean.rho+sd.rho, lower=mean.rho-sd.rho) %>%
  mutate_each(funs(cut_to_zero),-lib_size)

```

As before, we can plot the cross-map skill between MEI and *M. pyrifera*

```{r mei mac plot, echo=F}
mac_x_mei_plot <- ggplot()+
  geom_line(data=mac_xmap_mei_means,aes(x=lib_size,y=mean.rho,color="Macrocystis xmap MEI"))+
  geom_ribbon(data=mac_xmap_mei_means,aes(x=lib_size,ymin=lower,ymax=upper,fill="Macrocystis xmap MEI"),alpha=0.3)+
  geom_line(data=mei_xmap_mac_means,aes(x=lib_size,y=mean.rho,color="MEI xmap Macrocystis"))+
  geom_ribbon(data=mei_xmap_mac_means,aes(x=lib_size,ymin=lower,ymax=upper,fill="MEI xmap Macrocystis"),alpha=0.3)+
  scale_colour_manual(name=NULL, labels=c("Macrocystis xmap MEI","MEI xmap Macrocystis"),values=c("blue","darkgreen"))+
  scale_fill_manual(name=NULL, labels=c("Macrocystis xmap MEI","MEI xmap Macrocystis"),values=c("blue","darkgreen"))+
  theme(legend.key = element_blank(),legend.justification=c(0,1), legend.position=c(0,1),panel.background=element_rect(fill="white",color="black"))+
  ylim(-0.05,0.7) +
  geom_hline(yintercept=0,linetype=2,color="gray40")+
  ggtitle("Macrocystis and MEI Cross Mapping")+
  xlab("Library size")+
  ylab(expression(paste("Cross-map skill, ",rho)))

mac_x_mei_plot
```

And the other physical variables:

```{r ccm mac phys,echo=F}
### PDO ###
mac_xmap_pdo <- ccm(CCM.block.phys,E=bestE["pdo.mean"],lib_column="mac",target_column="pdo.mean",lib_sizes=c(seq(5,55,by=5),seq(55,1000,by=50)),lib=rnd_lib_segs,pred=rnd_pred_segs,random_libs=T,silent=T)

pdo_xmap_mac <- ccm(CCM.block.phys,E=bestE["mac"],lib_column = "pdo.mean", target_column = "mac",lib_sizes=c(seq(5,55,by=5),seq(55,1000,by=50)),lib=rnd_lib_segs,pred=rnd_pred_segs,random_libs=T,silent=T)

mac_xmap_pdo_means <- mac_xmap_pdo %>% 
  group_by(lib_size) %>% 
  summarise(mean.rho=mean(rho), sd.rho=sd(rho)) %>%
  mutate(upper=mean.rho+sd.rho, lower=mean.rho-sd.rho) %>%
  mutate_each(funs(cut_to_zero),-lib_size)

pdo_xmap_mac_means <- pdo_xmap_mac %>% 
  group_by(lib_size) %>% 
  summarise(mean.rho=mean(rho), sd.rho=sd(rho)) %>%
  mutate(upper=mean.rho+sd.rho, lower=mean.rho-sd.rho) %>%
  mutate_each(funs(cut_to_zero),-lib_size)

### NPGO ###
mac_xmap_npgo <- ccm(CCM.block.phys,E=bestE["npgo.mean"],lib_column="mac",target_column="npgo.mean",lib_sizes=c(seq(5,55,by=5),seq(55,1000,by=50)),lib=rnd_lib_segs,pred=rnd_pred_segs,random_libs=T,silent=T)

npgo_xmap_mac <- ccm(CCM.block.phys,E=bestE["mac"],lib_column = "npgo.mean", target_column = "mac",lib_sizes=c(seq(5,55,by=5),seq(55,1000,by=50)),lib=rnd_lib_segs,pred=rnd_pred_segs,random_libs=T,silent=T)

mac_xmap_npgo_means <- mac_xmap_npgo %>% 
  group_by(lib_size) %>% 
  summarise(mean.rho=mean(rho), sd.rho=sd(rho)) %>%
  mutate(upper=mean.rho+sd.rho, lower=mean.rho-sd.rho) %>%
  mutate_each(funs(cut_to_zero),-lib_size)

npgo_xmap_mac_means <- npgo_xmap_mac %>% 
  group_by(lib_size) %>% 
  summarise(mean.rho=mean(rho), sd.rho=sd(rho)) %>%
  mutate(upper=mean.rho+sd.rho, lower=mean.rho-sd.rho) %>%
  mutate_each(funs(cut_to_zero),-lib_size)

### Hs ###
mac_xmap_waves <- ccm(CCM.block.phys,E=bestE["waves.max"],lib_column="mac",target_column="waves.max",lib_sizes=c(seq(5,55,by=5),seq(55,1000,by=50)),lib=rnd_lib_segs,pred=rnd_pred_segs,random_libs=T,silent=T)

waves_xmap_mac <- ccm(CCM.block.phys,E=bestE["mac"],lib_column = "waves.max", target_column = "mac",lib_sizes=c(seq(5,55,by=5),seq(55,1000,by=50)),lib=rnd_lib_segs,pred=rnd_pred_segs,random_libs=T,silent=T)

mac_xmap_waves_means <- mac_xmap_waves %>% 
  group_by(lib_size) %>% 
  summarise(mean.rho=mean(rho), sd.rho=sd(rho)) %>%
  mutate(upper=mean.rho+sd.rho, lower=mean.rho-sd.rho) %>%
  mutate_each(funs(cut_to_zero),-lib_size)

waves_xmap_mac_means <- waves_xmap_mac %>% 
  group_by(lib_size) %>% 
  summarise(mean.rho=mean(rho), sd.rho=sd(rho)) %>%
  mutate(upper=mean.rho+sd.rho, lower=mean.rho-sd.rho) %>%
  mutate_each(funs(cut_to_zero),-lib_size)

### SST ###
mac_xmap_sst <- ccm(CCM.block.phys,E=bestE["sst.mean"],lib_column="mac",target_column="sst.mean",lib_sizes=c(seq(5,55,by=5),seq(55,1000,by=50)),lib=rnd_lib_segs,pred=rnd_pred_segs,random_libs=T,silent=T)

sst_xmap_mac <- ccm(CCM.block.phys,E=bestE["mac"],lib_column = "sst.mean", target_column = "mac",lib_sizes=c(seq(5,55,by=5),seq(55,1000,by=50)),lib=rnd_lib_segs,pred=rnd_pred_segs,random_libs=T,silent=T)

mac_xmap_sst_means <- mac_xmap_sst %>% 
  group_by(lib_size) %>% 
  summarise(mean.rho=mean(rho), sd.rho=sd(rho)) %>%
  mutate(upper=mean.rho+sd.rho, lower=mean.rho-sd.rho) %>%
  mutate_each(funs(cut_to_zero),-lib_size)

sst_xmap_mac_means <- sst_xmap_mac %>% 
  group_by(lib_size) %>% 
  summarise(mean.rho=mean(rho), sd.rho=sd(rho)) %>%
  mutate(upper=mean.rho+sd.rho, lower=mean.rho-sd.rho) %>%
  mutate_each(funs(cut_to_zero),-lib_size)

### Plots ###
mac_x_pdo_plot <- ggplot()+
  geom_line(data=mac_xmap_pdo_means,aes(x=lib_size,y=mean.rho,color="Macrocystis xmap pdo"))+
  geom_ribbon(data=mac_xmap_pdo_means,aes(x=lib_size,ymin=lower,ymax=upper,fill="Macrocystis xmap pdo"),alpha=0.3)+
  geom_line(data=pdo_xmap_mac_means,aes(x=lib_size,y=mean.rho,color="pdo xmap Macrocystis"))+
  geom_ribbon(data=pdo_xmap_mac_means,aes(x=lib_size,ymin=lower,ymax=upper,fill="pdo xmap Macrocystis"),alpha=0.3)+
  scale_colour_manual(name=NULL, labels=c("Macrocystis xmap pdo","pdo xmap Macrocystis"),values=c("purple","darkgreen"))+
  scale_fill_manual(name=NULL, labels=c("Macrocystis xmap pdo","pdo xmap Macrocystis"),values=c("purple","darkgreen"))+
  theme(legend.key = element_blank(),legend.justification=c(0,1), legend.position=c(0,1), panel.background=element_rect(fill="white",color="black"))+
  ylim(-0.05,0.7) +
  geom_hline(yintercept=0,linetype=2,color="gray40")+
  ggtitle("Macrocystis and pdo Cross Mapping")+
  xlab("Library size")+
  ylab(expression(paste("Cross-map skill, ",rho)))

mac_x_npgo_plot <- ggplot()+
  geom_line(data=mac_xmap_npgo_means,aes(x=lib_size,y=mean.rho,color="Macrocystis xmap npgo"))+
  geom_ribbon(data=mac_xmap_npgo_means,aes(x=lib_size,ymin=lower,ymax=upper,fill="Macrocystis xmap npgo"),alpha=0.3)+
  geom_line(data=npgo_xmap_mac_means,aes(x=lib_size,y=mean.rho,color="npgo xmap Macrocystis"))+
  geom_ribbon(data=npgo_xmap_mac_means,aes(x=lib_size,ymin=lower,ymax=upper,fill="npgo xmap Macrocystis"),alpha=0.3)+
  scale_colour_manual(name=NULL, labels=c("Macrocystis xmap npgo","npgo xmap Macrocystis"),values=c("orange","darkgreen"))+
  scale_fill_manual(name=NULL, labels=c("Macrocystis xmap npgo","npgo xmap Macrocystis"),values=c("orange","darkgreen"))+
  theme(legend.key = element_blank(),legend.justification=c(0,1), legend.position=c(0,1), panel.background=element_rect(fill="white",color="black"))+
  ylim(-0.05,0.7) +
  geom_hline(yintercept=0,linetype=2,color="gray40")+
  ggtitle("Macrocystis and npgo Cross Mapping")+
  xlab("Library size")+
  ylab(expression(paste("Cross-map skill, ",rho)))

mac_x_waves_plot <- ggplot()+
  geom_line(data=mac_xmap_waves_means,aes(x=lib_size,y=mean.rho,color="Macrocystis xmap waves"))+
  geom_ribbon(data=mac_xmap_waves_means,aes(x=lib_size,ymin=lower,ymax=upper,fill="Macrocystis xmap waves"),alpha=0.3)+
  geom_line(data=waves_xmap_mac_means,aes(x=lib_size,y=mean.rho,color="waves xmap Macrocystis"))+
  geom_ribbon(data=waves_xmap_mac_means,aes(x=lib_size,ymin=lower,ymax=upper,fill="waves xmap Macrocystis"),alpha=0.3)+
  scale_colour_manual(name=NULL, labels=c("Macrocystis xmap waves","waves xmap Macrocystis"),values=c("blue","darkgreen"))+
  scale_fill_manual(name=NULL, labels=c("Macrocystis xmap waves","waves xmap Macrocystis"),values=c("blue","darkgreen"))+
  theme(legend.key = element_blank(),legend.justification=c(0,1), legend.position=c(0,1), panel.background=element_rect(fill="white",color="black"))+
  ylim(-0.05,0.7) +
  geom_hline(yintercept=0,linetype=2,color="gray40")+
  ggtitle("Macrocystis and waves Cross Mapping")+
  xlab("Library size")+
  ylab(expression(paste("Cross-map skill, ",rho)))

mac_x_sst_plot <- ggplot()+
  geom_line(data=mac_xmap_sst_means,aes(x=lib_size,y=mean.rho,color="Macrocystis xmap sst"))+
  geom_ribbon(data=mac_xmap_sst_means,aes(x=lib_size,ymin=lower,ymax=upper,fill="Macrocystis xmap sst"),alpha=0.3)+
  geom_line(data=sst_xmap_mac_means,aes(x=lib_size,y=mean.rho,color="sst xmap Macrocystis"))+
  geom_ribbon(data=sst_xmap_mac_means,aes(x=lib_size,ymin=lower,ymax=upper,fill="sst xmap Macrocystis"),alpha=0.3)+
  scale_colour_manual(name=NULL, labels=c("Macrocystis xmap sst","sst xmap Macrocystis"),values=c("red","darkgreen"))+
  scale_fill_manual(name=NULL, labels=c("Macrocystis xmap sst","sst xmap Macrocystis"),values=c("red","darkgreen"))+
  theme(legend.key = element_blank(),legend.justification=c(0,1), panel.background=element_rect(fill="white",color="black"),legend.position=c(0,1))+
  ylim(-0.05,0.7) +
  geom_hline(yintercept=0,linetype=2,color="gray40")+
  ggtitle("Macrocystis and sst Cross Mapping")+
  xlab("Library size")+
  ylab(expression(paste("Cross-map skill, ",rho)))

#******************************
mac_x_mei_plot
mac_x_pdo_plot
mac_x_npgo_plot
mac_x_waves_plot
mac_x_sst_plot
```

We can also check for cross-map skill between the different physical variables themselves.  Are any of the variables redundant?

```{r ccm phys}
ncol <- dim(phys.dat.norm)[2] - 1
M_rho <- array(NA, dim = c(ncol, ncol), dimnames = list(colnames(phys.dat.norm[2:6]), 
    colnames(phys.dat.norm[2:6])))

for (i in 1:ncol) {
    for (j in 1:ncol) {
        if (i != j) {
            out_temp <- ccm(phys.dat.norm, E = 4, lib_column = 1 + i, target_column = 1 + 
                j, lib_sizes = dim(phys.dat.norm)[1], replace = FALSE, silent = TRUE)
            M_rho[i, j] <- out_temp$rho
        }
    }
}
rm(out_temp)

## we can also compare to a simple cross-correlation, allowing up to plus or minus 3 periods lag (about 18 months)
M_corr <- array(NA, dim = c(ncol, ncol), dimnames = list(colnames(phys.dat.norm[2:6]), 
    colnames(phys.dat.norm[2:6])))

for (i in 1:ncol) {
    for (j in 1:ncol) {
        if (i != j) {
            cf_temp <- ccf(x = phys.dat.norm[, 1 + i], y = phys.dat.norm[, 1 + 
                j], type = "correlation", lag.max = 3, na.action=na.pass,plot = FALSE)$acf
            M_corr[i, j] <- max(abs(cf_temp))
        }
    }
}
rm(cf_temp)
M_rho
M_corr

## SST and waves have very high cross-map skill and cross-correlation.  We want to reject the null hypothesis that 
```
We can re-run the previous all-species cross-mapping to build physical variables into our causation web.  For this exercise, we use the physical variables as predictors, but not predictees, since their values are the same across all of the spatial replicates.
```{r ccm all species and physical vars}
n_col <- dim(CCM.block.phys)[2]-1
n_row <- dim(CCM.block.phys)[2]-6
col_names <- colnames(CCM.block.phys)[2:(n_col+1)]
row_names <- colnames(CCM.block.phys)[2:(n_row+1)]
xmap_mat <- array(NA,dim=c(n_row,n_col),dimnames=list(row_names,col_names))

## CCM causation criterion 1: cross-map skill greater than zero
# matrix to store a bootstrapped p-value, measuring the probability that a given xmap is greater than zero (calculated as 
# 1 minus the number of positive results for rho divided by the number of iterations)
p1.mat <- array(NA,dim=c(n_row,n_col),dimnames=list(row_names,col_names))

## CCM causation criterion 2: evidence for convergence
# similarly, matrix to store a bootstrapped p-value, this time a t-test value between library size 10 and library size 500, to see if the rho at large library is significantly greater than the rho at small library size (i.e., looking for convergence).  If rho does not converge with library length, it may be a sign of synchrony.
p2.mat <- array(NA,dim=c(n_row,n_col),dimnames=list(row_names,col_names))

# if both p1 and p2 are positive, indicate overall significant causal signal
ptot.mat <- array(NA,dim=c(n_row,n_col),dimnames=list(row_names,col_names))

## Run CCM for each combination of variables
for(i in 1:n_row) {
  for(j in 1:n_col) {
    if(i != j) {
      # remember, we use the best embedding dimension for the library variable (the variable we're cross-mapping from, j)
      tempE=bestE[col_names[j]]
      temp <- ccm(CCM.block.phys,lib=rnd_lib_segs,pred=rnd_pred_segs,E=tempE,lib_column= 1+i,target_column = 1+j,lib_sizes = c(10,500,1000),replace=T,silent=T)
      # mean rho at library size 500
      rhomean <- temp %>% filter(lib_size==1000) %>% ccm_means()
      xmap_mat[i,j] <- rhomean$rho
      
      # first p-value (greater than zero? at largest library size)
      p1 <- temp %>% filter(lib_size==1000) %>% 
        mutate(pos=ifelse(rho>0,1,0)) %>%
        summarise(p=(1-sum(pos)/n()))
      p1.mat[i,j] <- as.numeric(p1)
      
      # second p-value (rho at lib-size 500 greater than rho at lib-size 10?)
      p2 <- t.test(temp$rho[temp$lib_size==10],temp$rho[temp$lib_size==500])$p.value
      p2.mat[i,j] <- as.numeric(p2)
      
      # overall significance (both p1 and p2 signficant at alpha 0.05)
      ptot.mat[i,j] <- ifelse(p1<0.05 & p2<0.05,1,0)
    }
  }
}
rm(tempE)
rm(temp)
```

Raster plot of output:
```{r CCM raster, echo=F}
# keep only signficant cross-mappings
xmap_mat <- xmap_mat*ptot.mat %>% as.data.frame()
xmap_rast_with_phys <- xmap_mat %>% 
  mutate(predictee=row.names(xmap_mat)) %>% 
  gather(key=predictor,value=rho,cys:sst.mean) %>%
  arrange(desc(rho))

# If rho is zero, replace with NA (no significant causal signal)
xmap_rast_with_phys$rho[xmap_rast_with_phys$rho==0] <- NA

## plot
xmap_all_phys_plot <- ggplot(xmap_rast_with_phys,aes(x=predictor,y=predictee,fill=rho)) +
  geom_raster() +
  scale_fill_distiller(palette="Spectral",name=expression(paste(rho, "(skill)"))) +
  ggtitle("Kelp Forest Convergent Cross Mapping") +
  xlab("Predictor") +
  ylab("Predictee") +
  theme(axis.text.x=element_text(angle = 90, hjust = 1,vjust=0.1))

xmap_all_phys_plot
#ggsave("xmap_all.png")

# list of significant variables for each species
ccm.sig.vars<-list()
for(i in 1:length(study_spp)) {
  spp <- study_spp[i]
  vars <- xmap_rast_with_phys %>% filter(predictee==spp,rho!=0)
  ccm.sig.vars[[spp]] <- vars$predictor
}
```

The physical variables display varying degrees of cross-map skill. Interesting, the Multivariate El Nino Index significantly maps to only two biological variables, and very weakly.  Conversely, the North Pacific Gyre Oscillation index significantly predicts all of the biological variables. In terms of individual species, that cross-mapping of SST and signficant wave height is strong by *Parastichopus parvimensis*, the warty sea cucumber.  *Macrocystis pyrifera* significantly cross-maps all of the physical variables, but most strongly maps SST.

### 6. Multivariate Models

Given that these species are so interconnected, it may be that we could better predict dynamics by building composite attractors from multiple species' time series. Similar to the theory behind CCM, extensions of Takens' theorem provide the basis for multivariate state-space reconstruction.  Using the normalized time series as before, we'll build library vectors that include lagged coordinates of the variable we're trying to predict, as well as other variables illuminated by our CCM analysis.

We do not want to just throw all variables into our multivariate reconstructions. Instead, we can add variables one by one, to see how much predictability they add to the overall model. To keep it simple for now, we'll focus on predicting the dynamics of *Macrocystis pyrifera*, and the candidate variables will be all of the biological and physical variables, and their associated lagged versions, up to 2 lags (~1 year).

We start with a univariate reconstruction (lagged versions of the same time series, just as in Section 3), and we get a similar prediction skill:
```{r create multivariate block, echo=F}
# Create a block of time series
# Similar to the block used for CCM, but for multivariate embeddings we have to manually lag the variables
multiblock <- dat.norm.block %>%
  group_by(site) %>%
  # join physical variables
  left_join(phys.dat.norm,by="period") %>%
  # manual lags for each variable (up to lag 2)
  mutate(mac.lag1=lag(mac,1),mac.lag2=lag(mac,2),
         pat.lag1=lag(pat,1),pat.lag2=lag(pat,2),
         red.lag1=lag(red,1),red.lag2=lag(red,2),
         purp.lag1=lag(purp,1),purp.lag2=lag(purp,2),
         wavy.lag1=lag(wavy,1),wavy.lag2=lag(wavy,2),
         paras.lag1=lag(paras,1),paras.lag2=lag(paras,2),
         pis.lag1=lag(pis,1),pis.lag2=lag(pis,2),
         cys.lag1=lag(cys,1),cys.lag2=lag(cys,2),
         lam.lag1=lag(lam,1),lam.lag2=lag(lam,2),
         eis.lag1=lag(eis,1),eis.lag2=lag(eis,2),
         pter.lag1=lag(pter,1),pter.lag2=lag(pter,2),
         mei.mean.lag1=lag(mei.mean,1),mei.mean.lag2=lag(mei.mean,2),
         pdo.mean.lag1=lag(pdo.mean,1),pdo.mean.lag2=lag(pdo.mean,2),
         npgo.mean.lag1=lag(npgo.mean,1),npgo.mean.lag2=lag(npgo.mean,2),
         waves.max.lag1=lag(waves.max,1),waves.max.lag2=lag(waves.max,2),
         sst.mean.lag1=lag(sst.mean,1),sst.mean.lag2=lag(sst.mean,2)) %>%
  ungroup() %>%
  select(-site)
```

The is what the relationship between observed and predicted values looks like for the optimal univariate reconstruction of *M. pyrifera*. The 1:1 line represnts what a perfect fit would look like, and the red best fit line shows the realized relationship. Overall forecast skill ($\rho$, the correlation between predictions and observations) is 0.577.
```{r mac univariate, echo=F}
mac.univar <- simplex(multiblock$mac,E=6,lib=rnd_lib_segs,pred=rnd_pred_segs,stats_only = F,silent=T)

# We can plot observed vs. predicted values to see how well the univariate reconstruction did
univar.out <- mac.univar[[1]]$model_output

# Correlation between observed and predicted
univar.corr <- round(mac.univar[[1]]$stats$rho,3)

par(mfrow=c(1,1),xpd=F)
plot_range <- range(c(univar.out$obs, univar.out$pred), na.rm = TRUE)
plot(univar.out$obs,univar.out$pred,xlab="Observed",ylab="Predicted",xlim=plot_range,ylim=plot_range,cex=0.8,main=expression(paste("Macrocystis Univariate Embedding (E=6), ",rho,"=0.577")))

# "Perfect fit", 1:1 line
abline(a=0,b=1,lty=2,col="gray40")
# Best fit line
abline(lm(univar.out$pred ~ univar.out$obs), col = "darkred", lty = 3, lwd = 2)
```


#### Model Selection for *Macrocystis*
Now, we want to find the combination of variables that best describe *M. pyrifera* dynamics at SNI. However, we don't want to just haphazardly throw variables together. Instead, we'll use a forward selection procedure to determine which variables to include, by first finding the single variable that best predicts kelp dynamics (determined by $\rho$).

```{r macro multi model selection}
# A vector of all variables names (first column is period identifier)
# multi_vars <- colnames(multiblock)[2:17]

# potential variables are those that significantly cross-mapped from the previous step, plus mac itself
multi_vars <- c(ccm.sig.vars[["mac"]],"mac")
# Vector to hold output rho's and thetas
out.rho <- numeric(length(multi_vars))
names(out.rho) <- multi_vars
out.theta <- numeric(length(multi_vars))
names(out.theta) <- multi_vars

# Find the single variable that best predicts M. pyrifera dynamics (including the mac time series itself)
ptm <- proc.time()
for(i in 1:length(multi_vars)) {
  temp_var <- multi_vars[i]
  temp <- block_lnlp(multiblock,lib=rnd_lib_segs,pred=rnd_pred_segs,columns=temp_var,target_column = "mac",theta = c(0, 1e-04, 3e-04, 0.001,0.003, 0.01, 0.1, 0.5, 1, 2, 4, 6, 8),method="s-map")
  out.rho[i] <- max(temp$rho,na.rm=T)
  out.theta[i] <- temp$theta[temp$rho==max(temp$rho)]
}
out.rho <- data_frame(var=names(out.rho),rho=out.rho,theta=out.theta) %>% arrange(desc(rho))
out.rho
rm(temp_var,temp)
proc.time()-ptm
```

All of the physical variables, and their lags, arise as the most predictive single variables for predicting *M. pyrifera* dynamics. Continuing with forward selection, we now find the next variable, after significant wave height (lag 1), that adds the most predictability (i.e., displays the largest improvement over the univariate forecast). We'll do this iteratively, and see how many steps/variables to include before predicability stops improving with the addition of additional variables

.

```{r forward selection}
selected.vars <- data_frame(var=rep(NA,10),cum.rho=numeric(10),theta=numeric(10))

# We'll do 15 model selection steps, adding the most predictive variable each time
# timer
ptm <- proc.time()
for(i in 1:10) {
  # candidate variables are all those that have not yet been selected
  poss_vars <- setdiff(multi_vars,selected.vars$var)
  # Vector to hold output rho's
  out.rho <- numeric(length(poss_vars))
  names(out.rho) <- poss_vars
  out.theta <- numeric(length(poss_vars))
  names(out.theta) <- poss_vars
  
  # Find the single variable that best predicts M. pyrifera dynamics (including the mac time series itself)
  for(j in 1:length(poss_vars)) {
    # For each iteration, we use all the previously selected variables, plus one new candidate variable, to create reconstructions
    temp_vars <- c(selected.vars$var[!is.na(selected.vars$var)],poss_vars[j])
    temp <- block_lnlp(multiblock,lib=as.matrix(segs),pred=as.matrix(segs),columns=temp_vars,target_column = "mac",theta = c(0, 1e-04, 3e-04, 0.001,0.003, 0.01, 0.1, 0.5, 1, 2, 4, 6, 8),method="s-map",silent=T)
  out.rho[j] <- max(temp$rho,na.rm=T)
  out.theta[j] <- temp$theta[temp$rho==max(temp$rho)][1]
  }
  selected.vars$var[i] <- names(out.rho)[out.rho==max(out.rho)]
  selected.vars$cum.rho[i] <- max(out.rho)
  selected.vars$theta[i] <- out.theta[out.rho==max(out.rho)]
}
proc.time()-ptm
selected.vars

# Plot results
plot.new()
par(mfrow=c(1,1))
plot(1:10,selected.vars$cum.rho,type="l",main="Forward Model Selection for Macrocystis Dynamics",xlab="Model Selection Step (= Number of Variables Included)",ylab=expression(paste("Model Predictive Skill, ",rho)))
```

The model selection exercise peaks in forecast skill with nine included variables. There are many interesting observations from this exercise:

* The best model has a skill of greater than 0.75 and consists of a reconstruction with four physical variables of two types (MEI/El Nino and significant wave height), and five biological variables from four species (the urchins *Strogylocentrotus fransciscanus* and *S. purpuratus*, wavy turban snail *Megastreaea undosa*, and the bat star *Patiria miniata*)
* *Macrocystis pyrifera* itself does not show up as a signficant variable. The time series reconstructed with one lag of *M. pyrifera* was the last-selected variable, after the peak in predictive ability
* The two first selected variables relate to significant wave height, confirming other findings. Together, wave dynamics and its first lag produce predictions with a correlation of >0.5 with observations.
* Three of the top five selected variables are physical, but the other two are related to biological variables, specifically urchin dynamics. However, the selected urchin variables are lags, potentially suggesting that adult *M. pyrifera* dynamics are determined by urchin effects on younger life stages of *M. pyrifera* (e.g., recruitment and juvenile growth), rather than contemporaneous effects of urchins on adult kelps.
* The total number of unique variables (six, excluding lags) is the same as the best embedding dimension for modeling *M. pyrifera* using univariate simplex projection (see Step 3 above)

We can see one illustration of model by comparing the best multivariate model with the best univariate model for *Macrocystis*.

```{r univar vs multivar prediction mac}
# Run best multivariate model for M. pyrifera, saving actual model output (option stats_only=F)
mac.multi.vars <- selected.vars$var[1:2]
mac.multi.mod <- block_lnlp(multiblock,lib=as.matrix(segs),pred=as.matrix(segs),columns=mac.multi.vars,target_column = "mac",stats_only = F,method="s-map",theta=2)
mac.multi.out <- mac.multi.mod[[1]]$model_output

# Re-draw the univariate scatter
par(mfrow=c(1,1),xpd=F)
plot_range <- range(c(univar.out$obs, univar.out$pred), na.rm = TRUE)
plot(univar.out$obs,univar.out$pred,xlab="Observed",ylab="Predicted",col="darkred",xlim=plot_range,ylim=plot_range,pch=1,main=expression(paste("Best Univariate vs. Multivariate Model of Macrocystis Dynamics")))

# Add best multivariate fit
points(mac.multi.out$obs,mac.multi.out$pred,col="darkgreen",pch=2)
# "Perfect fit", 1:1 line
abline(a=0,b=1,lty=2,col="gray40")
# Best fit line for univariate and multivariate models
abline(lm(univar.out$pred ~ univar.out$obs), col = "darkred", lty = 3, lwd = 3)
abline(lm(mac.multi.out$pred ~ mac.multi.out$obs),col="darkgreen", lty=3, lwd=3)

# Legend
legend("topleft",legend=c("best univariate model","best multivariate model","1:1 line"),col=c("darkred","darkgreen","gray40"),lty=c(3,3,2),lwd=c(3,3,2))
```
Again, the best nonlinear, multivariate model of *Macrocystis pyrifera* dynamics outperforms the best univariate model, and does not include *Macrocystis* itself as a predictor.

#### Model Selection, All Species
We can generalize the above analysis of *M. pyrifera* dynamics and find the best multivariate model for each of the species in our data. The model selection will follow the same procedure as the previous exercise: sequentially identifying the variables that most improve model skill.

```{r multivariate model selection all species}
# List to hold each model selection output
multivar.models <- list()

# Run model selection for each study species
ptm<-proc.time()
for(k in 1:length(study_spp)) {
  spp <- study_spp[k]
  var.lib <- c(ccm.sig.vars[[spp]],spp)
  # We'll do a number of model selection steps (max 10), adding the most predictive variable each time
  selection.steps <- min(10, length(var.lib))
  
  selected.vars <- data_frame(var=rep(NA,selection.steps),cum.rho=numeric(selection.steps),theta=numeric(selection.steps))


  for(i in 1:selection.steps) {
    # candidate variables are all those that have not yet been selected
    poss_vars <- setdiff(var.lib,selected.vars$var)
    # Vectors to hold output rho's and thetas
    out.rho <- numeric(length(poss_vars))
    names(out.rho) <- poss_vars
    out.theta <- numeric(length(poss_vars))
    names(out.theta) <- poss_vars
    
    for(j in 1:length(poss_vars)) {
      # For each iteration, we use all the previously selected variables, plus one new candidate variable, to create reconstructions
      temp_vars <- c(selected.vars$var[!is.na(selected.vars$var)],poss_vars[j])
      
      temp <- block_lnlp(multiblock,lib=rnd_lib_segs,pred=rnd_pred_segs,columns=temp_vars,target_column = spp,theta = c(0, 1e-04, 3e-04, 0.001,0.003, 0.01, 0.1, 0.5, 1, 2, 4, 6, 8),num_neighbors=0,method="s-map",silent=T)
      out.rho[j] <- max(temp$rho)
      out.theta[j] <-  temp$theta[temp$rho==max(temp$rho)][1]
    }
    new.var <- names(out.rho)[out.rho==max(out.rho,na.rm=T)] %>% subset(!is.na(.))
    selected.vars$var[i] <- new.var
    selected.vars$cum.rho[i] <- out.rho[new.var]
    selected.vars$theta[i] <- out.theta[new.var]
  }
  # Store results
  multivar.models[[spp]] <- selected.vars
}
ptm-proc.time()
```

Here's the plots of the model selection exercise for each species.  We also include, for reference, a dashed line representing the skill of the best univariate model for each species.

```{r model selection plots, echo=F}
par(mfrow=c(2,2))

for(i in 1:length(multivar.models)) {
  rho <- multivar.models[[i]]$cum.rho
  selection.steps <- nrow(multivar.models[[i]])
  plot(1:selection.steps,rho,type="l",main=c("Forward Model Selection",study_spp[i]),xlab="Model Selection Step (= Number of Variables Included)",xlim=c(0,selection.steps),ylab=expression(paste("Model Predictive Skill, ",rho)),ylim=c(0.2,0.8),xaxs="i")
  # Add line for best univariate model (from back in Step 3)
  abline(h=max(simp.list[[i]]$rho),lty=2,col="gray40")
}
par(mfrow=c(1,1))
```

The best multivariate model for each species strictly and often greatly outperforms the best univariate (self-predicting) models, as evidenced by the difference between the solid and dotted lines in the above plots.  All multivariate models with the exception of the models for *Pisaster giganteus* and *Eisenia arborea* exceed a model skill ($/rho$) of 0.5.  Most models "saturate" with fewer than 10 included variables, or at least reach a point where each additional variable add very little predictive skill (i.e., additional dynamic information).

We can also investigate the included variables in each of the models, and see what the common variables are across models. To do this, we have to decide on the best multivariate model for each species. For consistency and to avoid overfitting, we'll choose the model for each species >= 2 variables where the model skill ($\rho$) first reaches a local maximum (i.e., where the next added variable decreases $\rho$).

```{r choose best multivar model}
best.modls <- list()
nvars <- data_frame(model=study_spp,nvar=NA) # number of variables included in each model

for(i in 1:length(multivar.models)) {
  modl <- multivar.models[[i]]$cum.rho[2:selection.steps]
  # Find first local maximum
  cutoff <- match(TRUE,diff(modl)<0) + 1
  # Slice original model selection
  best.modls[[i]] <- slice(multivar.models[[i]],1:cutoff)
  nvars[i,'nvar'] <- cutoff
}
names(best.modls) <- names(multivar.models)

```

Now we can get a sense of the variables included in the models.

```{r count vars}
varlist <- data_frame(vars=unlist(lapply(best.modls,function(x) x$var),use.names = F))
count.vars <- varlist %>% count(vars, sort=T)
count.vars

# number of bioligcal variables
n_biol_vars <- sum(sapply(study_spp,function(x) grepl(x,count.vars$vars)))
n_phys_vars <- nrow(count.vars)-n_biol_vars
```

Some results:

* The 11 best models contain a total of 59 unique variables, of which 14 are physical variables, and 17 are biological variables. 
* The models contain a median of 4 variables, with the maximum number of included variables being 11 (*Strongylocentrotus purpuratus* model).  
* All 5 physical variables are represented in some form (lagged or not) in at least 3 of the 11 models.
* All models include at least 2 physical variables, and each model contains a physical variable as the first-selected variable, except for the model for *Cystoseira osmundacea*
* Four models contain only physical variables:
  + *Patiria miniata*
  + *Megastreaea undosa*
  + *Parastichopus parvimensis*
  + *Pisaster giganteus*
* Four models include their own time series (past density): red,purp,cys,eis,
* Seven models include other species' time series: red, purp,cys,lam,eis,pter,mac

This is not the only way to do model selection, but is one of the least demanding computationally because of the large number of variables. Other potential options would be to force each model to include its own dynamics as part of the reconstruction (e.g., the model for *Macrocystis* would include its own time series), or to start with only the variables significantly cross-mapped in Step 5.

### Real-Time Kelp Forest Interactions

From the results of the cross-mapping and multivariate modeling exercises, it is clear that the algal and invertebrate species in this species interact with one another in nonlinear, complex, but potentially predictable ways. Now that we have a multivariate predictive model for each species' dynamics, we can look at these phenomena in more detail, and answer the questions:

  * *Are interactions between species constant over time (in both direction and magnitude)?*
  * *If not, are there predictable conditions under which we may expect a certain type of interaction (e.g., competition vs. facilitation)?*

Examples of more species-specific questions include:

  * *Can we distinguish between times of top-down vs. bottom-up forcing of Macrocystis dynamics?*
  * *Do Eisenia arborea and Pterogophora californica, both understory kelps, always compete?*
  * *What are the conditions under which the invertebrates compete vs. facilitate one another?*
  
The exploration of these questions will give us insight into a more mechanistic view of the nonlinear interactions in this dynamic system.

For this exercise, we use S-maps to investigate the interactions strengths between physical variables and species, and species with one another, in real time. S-maps actually calculates sequential "Jacobian" community matrices (the local effect of each variable on every other variable) at each time step in the analysis. By explicitly recording these, we can reveal how species interactions are changing over time. The logic and calculations behind this are described in Sugihara (1994) and Deyle et al. (2016).

As before, we begin with a simplified model as a proof of concept. We'll look at the interactions affecting red urchins, *Strongylocentrotus fransciscanus*. The best forward-selected multivariate model for *S. fransciscanus* from the previous Step contained 7 variables of 5 unique types: sea surface temperature, red urchin density (i.e., its own time series), wavy turban snail density, the North Pacific Gyre Oscillation Index, and the Pacific Decadal Oscillation index. Here we use the seven-dimensional embedding from the best model to fit s_map coefficients.

```{r red urchin interactions}
# Start simple
red.smap.full <- block_lnlp(multiblock,lib=as.matrix(segs),method="s-map",columns=best.modls[['red']]$var,target_column = "red",theta=best.modls[['red']]$theta[2],save_smap_coefficients = TRUE,num_neighbors = 0)
red.smap.full <-red.smap.full[[1]]
red.obs <- red.smap.full$model_output
red.coeffs <- red.smap.full$smap_coefficients

# Plot of model output for one set of data
par(mfrow=c(1,1))
plot(red.obs$time[820:882],red.obs$obs[820:882],type="l",main="Red Urchin Density",xlab="Period",ylab="Density (Standardized)", xaxs="i",col="black")
lines(red.obs$time[819:881],red.obs$pred[820:882],col="darkred",lty=2)
```

backwards selection, macrocystis

```{r mac model back selection}
ptm <- proc.time()
mac.back.vars <- c(ccm.sig.vars[["mac"]],"mac")

nsteps <- length(mac.back.vars)

mac.back.mod <- data_frame(ex.var=character(nsteps),rho=numeric(nsteps),theta=numeric(nsteps))
mac.full <- block_lnlp(multiblock,lib=as.matrix(segs),pred=as.matrix(segs),columns=mac.back.vars,target_column = "mac",theta = c(0, 1e-04, 3e-04, 0.001,0.003, 0.01, 0.1, 0.5, 1, 2, 4, 6,8), num_neighbors=0,method="s-map",silent=T)

mac.back.mod$ex.var[1] <- "none"
mac.back.mod$rho[1] <- max(mac.full$rho,na.rm=T)
mac.back.mod$theta[1] <- mac.full$theta[mac.full$rho==max(mac.full$rho,na.rm=T)]


for(i in 2:nsteps) {
  # candidate variables are all those that have not yet been selected
  poss_vars <- setdiff(mac.back.vars,mac.back.mod$ex.var)
  # Vectors to hold output rho's and thetas
  out.rho <- numeric(length(poss_vars))
  names(out.rho) <- poss_vars
  out.theta <- numeric(length(poss_vars))
  names(out.theta) <- poss_vars
  
  for(j in 1:length(poss_vars)) {
    # For each iteration, we remove one variable at a time
    temp_vars <- poss_vars[-j]
    
    temp <- block_lnlp(multiblock,lib=as.matrix(segs),pred=as.matrix(segs),columns=temp_vars,target_column = "mac",theta = c(0, 1e-04, 3e-04, 0.001,0.003, 0.01, 0.1, 0.5, 1, 2, 4, 6,8), num_neighbors=0,method="s-map",silent=T)
    out.rho[j] <- max(temp$rho)
    out.theta[j] <-  temp$theta[temp$rho==max(temp$rho)][1]
  }
  ex.var <- names(out.rho)[out.rho==max(out.rho,na.rm=T)] %>% subset(!is.na(.))
  mac.back.mod$ex.var[i] <- ex.var
  mac.back.mod$rho[i] <- out.rho[ex.var]
  mac.back.mod$theta[i] <- out.theta[ex.var]
}

proc.time()-ptm

plot(1:nsteps,mac.back.mod$rho,main="Macrocystis Backwards Model Selection",xlab="Variables Excluded",ylab="Model Predictive Skill",type="l")
```

With this model, we can explore the dynamics of interactions

```{r mac dynamic interactions}
# We save s-map coefficients, and choose the theta corresponding to the best selected model
dyn.vars <- c(mac.back.mod$ex.var[6:13],"sst.mean")

mac.dyn <- block_lnlp(multiblock,lib=as.matrix(segs),pred=as.matrix(segs),columns=dyn.vars,target_column = "mac",theta = 4, num_neighbors=0,method="s-map",save_smap_coefficients=T,silent=T)[[1]]

mac.dyn$stats

dyn.coeffs <- mac.dyn$smap_coefficients %>% as.data.frame()
names(dyn.coeffs) <- c(dyn.vars,"constant")
dyn.pred <- mac.dyn$model_output

# Average effects of each interactions
mean.na <- function(x) mean(x,na.rm=T)
var.na <- function(x) var(x,na.rm=T)
dyn.coef.long <- dyn.coeffs %>% gather(key=effect,value=value,na.rm=T) %>%
  group_by(effect)

# Plot of density/value vs. interactive effect for all covariates
ggplot(dyn.coef.long,aes(x=value)) +
  geom_histogram(aes(y=..density..),bins=10) +
  theme_minimal() +
  xlab("Interaction Strength") +
  ylab("Frequency")+
  geom_vline(xintercept=0,linetype=2)+
  ggtitle("Effects of Variables on Macrocystis Dynamics")+
  facet_wrap(~effect)

ggplot(dyn.coef.long,aes(x=effect,y=value,fill=effect))+
  geom_boxplot()

#Predicted vs. Observed
plot(dyn.pred$obs,dyn.pred$pred, main="Observed vs. Predicted, Macrocystis Multivariate Model",xlab="Observed",ylab="Predicted")
abline(a=0,b=1,lty=2,col="gray40")
abline(lm(dyn.pred$pred~dyn.pred$obs),lty=1,col="darkgreen")

```
